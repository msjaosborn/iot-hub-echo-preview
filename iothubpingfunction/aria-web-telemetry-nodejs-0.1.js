var request = require('request');

var clienttelemetry_build;
(function (clienttelemetry_build) {
    clienttelemetry_build.version = "2.2.0";
})(clienttelemetry_build || (clienttelemetry_build = {}));
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
//     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
//     File     : bond_const.ts
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        (function (BondDataType) {
            BondDataType[BondDataType["BT_STOP"] = 0] = "BT_STOP";
            BondDataType[BondDataType["BT_STOP_BASE"] = 1] = "BT_STOP_BASE";
            BondDataType[BondDataType["BT_BOOL"] = 2] = "BT_BOOL";
            BondDataType[BondDataType["BT_UINT8"] = 3] = "BT_UINT8";
            BondDataType[BondDataType["BT_UINT16"] = 4] = "BT_UINT16";
            BondDataType[BondDataType["BT_UINT32"] = 5] = "BT_UINT32";
            BondDataType[BondDataType["BT_UINT64"] = 6] = "BT_UINT64";
            BondDataType[BondDataType["BT_FLOAT"] = 7] = "BT_FLOAT";
            BondDataType[BondDataType["BT_DOUBLE"] = 8] = "BT_DOUBLE";
            BondDataType[BondDataType["BT_STRING"] = 9] = "BT_STRING";
            BondDataType[BondDataType["BT_STRUCT"] = 10] = "BT_STRUCT";
            BondDataType[BondDataType["BT_LIST"] = 11] = "BT_LIST";
            BondDataType[BondDataType["BT_SET"] = 12] = "BT_SET";
            BondDataType[BondDataType["BT_MAP"] = 13] = "BT_MAP";
            BondDataType[BondDataType["BT_INT8"] = 14] = "BT_INT8";
            BondDataType[BondDataType["BT_INT16"] = 15] = "BT_INT16";
            BondDataType[BondDataType["BT_INT32"] = 16] = "BT_INT32";
            BondDataType[BondDataType["BT_INT64"] = 17] = "BT_INT64";
            BondDataType[BondDataType["BT_WSTRING"] = 18] = "BT_WSTRING";
            BondDataType[BondDataType["BT_UNAVAILABLE"] = 127] = "BT_UNAVAILABLE";
        })(Bond.BondDataType || (Bond.BondDataType = {}));
        var BondDataType = Bond.BondDataType;

        (function (ProtocolType) {
            ProtocolType[ProtocolType["MARSHALED_PROTOCOL"] = 0] = "MARSHALED_PROTOCOL";
            ProtocolType[ProtocolType["MAFIA_PROTOCOL"] = 17997] = "MAFIA_PROTOCOL";
            ProtocolType[ProtocolType["COMPACT_PROTOCOL"] = 16963] = "COMPACT_PROTOCOL";
            ProtocolType[ProtocolType["JSON_PROTOCOL"] = 21322] = "JSON_PROTOCOL";
            ProtocolType[ProtocolType["PRETTY_JSON_PROTOCOL"] = 20554] = "PRETTY_JSON_PROTOCOL";
            ProtocolType[ProtocolType["SIMPLE_PROTOCOL"] = 20563] = "SIMPLE_PROTOCOL";
        })(Bond.ProtocolType || (Bond.ProtocolType = {}));
        var ProtocolType = Bond.ProtocolType;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        (function (Collections) {
            var Set = (function () {
                function Set() {
                    this._buffer = [];
                }
                Set.prototype.Add = function (t) {
                    var i = 0;
                    for (; i < this._buffer.length; ++i) {
                        if (this._buffer[i] == t) {
                            break;
                        }
                    }
                    if (i == this._buffer.length) {
                        this._buffer.push(t);
                    }
                };

                Set.prototype.Count = function () {
                    return this._buffer.length;
                };

                Set.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return Set;
            })();
            Collections.Set = Set;

            // Modified bond code to add AddorReplace and Remove for Map
            //TODO(abpanwar): Contact the bond team to add this to their library.
            var Map = (function () {
                function Map() {
                    this._buffer = [];
                }
                Map.prototype.Add = function (key, value) {
                    if (this._getIndex(key) == -1) {
                        this._buffer.push({ Key: key, Value: value });
                    }
                };

                Map.prototype.AddOrReplace = function (key, value) {
                    var i = this._getIndex(key);
                    if (i >= 0) {
                        this._buffer[i] = { Key: key, Value: value };
                    } else {
                        this._buffer.push({ Key: key, Value: value });
                    }
                };

                Map.prototype.Remove = function (key) {
                    var i = this._getIndex(key);
                    if (i >= 0) {
                        this._buffer.splice(i, 1);
                    }
                };

                Map.prototype.Count = function () {
                    return this._buffer.length;
                };

                Map.prototype.GetBuffer = function () {
                    return this._buffer;
                };

                Map.prototype._getIndex = function (key) {
                    var i = 0;
                    var index = -1;
                    for (; i < this._buffer.length; ++i) {
                        if (this._buffer[i].Key == key) {
                            index = i;
                            break;
                        }
                    }
                    return index;
                };
                return Map;
            })();
            Collections.Map = Map;
        })(Bond.Collections || (Bond.Collections = {}));
        var Collections = Bond.Collections;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        (function (Encoding) {
            var Utf8 = (function () {
                function Utf8() {
                }
                Utf8.GetBytes = function (value) {
                    var array = [];
                    for (var i = 0; i < value.length; ++i) {
                        var char = value.charCodeAt(i);
                        if (char < 0x80) {
                            array.push(char);
                        } else if (char < 0x800) {
                            array.push(0xc0 | (char >> 6), 0x80 | (char & 0x3f));
                        } else if (char < 0xd800 || char >= 0xe000) {
                            array.push(0xe0 | (char >> 12), 0x80 | ((char >> 6) & 0x3f), 0x80 | (char & 0x3f));
                        } else {
                            char = 0x10000 + (((char & 0x3ff) << 10) | (value.charCodeAt(++i) & 0x3ff));
                            array.push(0xf0 | (char >> 18), 0x80 | ((char >> 12) & 0x3f), 0x80 | ((char >> 6) & 0x3f), 0x80 | (char & 0x3f));
                        }
                    }
                    return array;
                };
                return Utf8;
            })();
            Encoding.Utf8 = Utf8;

            var Base64 = (function () {
                function Base64() {
                }
                Base64.GetString = function (inArray) {
                    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    var output = [];
                    var paddingBytes = inArray.length % 3;
                    var i, temp, length;

                    var toBase64 = function (num) {
                        return [
                            lookup.charAt((num >> 18) & 0x3F),
                            lookup.charAt((num >> 12) & 0x3F),
                            lookup.charAt((num >> 6) & 0x3F),
                            lookup.charAt(num & 0x3F)].join("");
                    };

                    for (i = 0, length = inArray.length - paddingBytes; i < length; i += 3) {
                        temp = (inArray[i] << 16) + (inArray[i + 1] << 8) + (inArray[i + 2]);
                        output.push(toBase64(temp));
                    }

                    switch (paddingBytes) {
                        case 1:
                            temp = inArray[inArray.length - 1];
                            output.push(lookup.charAt(temp >> 2));
                            output.push(lookup.charAt((temp << 4) & 0x3F));
                            output.push('==');
                            break;

                        case 2:
                            temp = (inArray[inArray.length - 2] << 8) + (inArray[inArray.length - 1]);
                            output.push(lookup.charAt(temp >> 10));
                            output.push(lookup.charAt((temp >> 4) & 0x3F));
                            output.push(lookup.charAt((temp << 2) & 0x3F));
                            output.push('=');
                            break;
                    }
                    return output.join("");
                };
                return Base64;
            })();
            Encoding.Base64 = Base64;

            var Varint = (function () {
                function Varint() {
                }
                Varint.GetBytes = function (value) {
                    var array = [];
                    while (value & 0xffffff80) {
                        array.push((value & 0x7f) | 0x80);
                        value >>>= 7;
                    }
                    array.push(value & 0x7f);
                    return array;
                };
                return Varint;
            })();
            Encoding.Varint = Varint;

            var Varint64 = (function () {
                function Varint64() {
                }
                Varint64.GetBytes = function (value) {
                    var low = value.low;
                    var high = value.high;
                    var array = [];
                    while (high || (0xffffff80 & low)) {
                        array.push((low & 0x7f) | 0x80);
                        low = ((high & 0x7f) << 25) | (low >>> 7);
                        high >>>= 7;
                    }
                    array.push(low & 0x7f);
                    return array;
                };
                return Varint64;
            })();
            Encoding.Varint64 = Varint64;

            var Float = (function () {
                function Float() {
                }
                Float.GetBytes = function (value) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(4));
                        view.setFloat32(0, value, true);

                        var array = [];
                        for (var i = 0; i < 4; ++i) {
                            array.push(view.getUint8(i));
                        }
                        return array;
                    } else {
                        return FloatUtils.ConvertNumberToArray(value, false);
                    }
                };
                return Float;
            })();
            Encoding.Float = Float;

            // Note: see notes of Float.
            var Double = (function () {
                function Double() {
                }
                Double.GetBytes = function (value) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(8));
                        view.setFloat64(0, value, true);

                        var array = [];
                        for (var i = 0; i < 8; ++i) {
                            array.push(view.getUint8(i));
                        }
                        return array;
                    } else {
                        return FloatUtils.ConvertNumberToArray(value, true);
                    }
                };
                return Double;
            })();
            Encoding.Double = Double;

            var Zigzag = (function () {
                function Zigzag() {
                }
                Zigzag.EncodeZigzag16 = function (value) {
                    value = Bond.Number.ToInt16(value);
                    return ((value << 1) ^ (value >> (2 * 8 - 1)));
                };

                Zigzag.EncodeZigzag32 = function (value) {
                    value = Bond.Number.ToInt32(value);
                    return ((value << 1) ^ (value >> (4 * 8 - 1)));
                };

                Zigzag.EncodeZigzag64 = function (value) {
                    var low = value.low;
                    var high = value.high;
                    var tmpH = (high << 1) | (low >>> 31);
                    var tmpL = low << 1;
                    if (high & 0x80000000) {
                        tmpH = ~tmpH;
                        tmpL = ~tmpL;
                    }

                    var res = new Bond.UInt64("0");
                    res.low = tmpL;
                    res.high = tmpH;
                    return res;
                };
                return Zigzag;
            })();
            Encoding.Zigzag = Zigzag;
        })(Bond.Encoding || (Bond.Encoding = {}));
        var Encoding = Bond.Encoding;

        (function (Decoding) {
            var Utf8 = (function () {
                function Utf8() {
                }
                Utf8.GetString = function (data) {
                    var res = [];
                    for (var i = 0; i < data.length; ++i) {
                        var c1 = data[i];
                        if (c1 <= 191) {
                            res.push(String.fromCharCode(c1));
                        } else if (c1 <= 223) {
                            var c2 = data[++i];
                            res.push(String.fromCharCode(((c1 & 31) << 6) | (c2 & 63)));
                        } else if (c1 <= 239) {
                            var c2 = data[++i];
                            var c3 = data[++i];
                            res.push(String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                        } else {
                            var c2 = data[++i];
                            var c3 = data[++i];
                            var c4 = data[++i];
                            c1 = ((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63);
                            c1 -= 0x10000;
                            res.push(String.fromCharCode(0xd800 | ((c1 >> 10) & 0x3ff)));
                            res.push(String.fromCharCode(0xdc00 | (c1 & 0x3ff)));
                        }
                    }
                    return res.join("");
                };
                return Utf8;
            })();
            Decoding.Utf8 = Utf8;

            var Base64 = (function () {
                function Base64() {
                }
                Base64.GetBytes = function (base64Str) {
                    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    var res = [];
                    for (var i = 0; i < base64Str.length; ++i) {
                        var byte1 = lookup.indexOf(base64Str.charAt(i++));
                        var byte2 = lookup.indexOf(base64Str.charAt(i++));
                        var byte3 = lookup.indexOf(base64Str.charAt(i++));
                        var byte4 = lookup.indexOf(base64Str.charAt(i));

                        res.push(byte1 << 2 | byte2 >> 4);
                        if (byte3 >= 0) {
                            res.push((byte2 << 4) & 0xF0 | byte3 >> 2);

                            if (byte4 >= 0) {
                                res.push((byte3 << 6) & 0xC0 | byte4);
                            }
                        }
                    }
                    return res;
                };
                return Base64;
            })();
            Decoding.Base64 = Base64;

            var Varint = (function () {
                function Varint() {
                }
                Varint.GetInt64 = function (buffer) {
                    var int64 = new Microsoft.Bond.Int64("0");
                    var data = this._Read(buffer);
                    int64.low = data[0];
                    if (data.length > 1) {
                        int64.high = data[1];
                    }
                    return int64;
                };

                Varint.GetNumber = function (buffer) {
                    return this._Read(buffer)[0];
                };

                Varint._Read = function (buffer) {
                    var result = [];
                    var tmp = 0;
                    var hasMore = true;
                    var readedBits = 0;

                    while (hasMore) {
                        var raw = buffer.shift();
                        hasMore = (raw & 0x80) != 0;
                        raw = raw & 0x7F;
                        if (readedBits < 28) {
                            tmp |= raw << readedBits;
                            readedBits += 7;
                        } else {
                            // only lower 4 bits can be put
                            tmp |= raw << readedBits;
                            result.push(tmp);
                            tmp = raw >> 4;
                            readedBits = 3;
                            break;
                        }
                    }

                    while (hasMore) {
                        var raw = buffer.shift();
                        hasMore = (raw & 0x80) != 0;
                        raw = raw & 0x7F;
                        tmp |= raw << readedBits;
                        readedBits += 7;
                        if (readedBits >= 32) {
                            break;
                        }
                    }
                    result.push(tmp);
                    return result;
                };
                return Varint;
            })();
            Decoding.Varint = Varint;

            var Float = (function () {
                function Float() {
                }
                Float.GetNumber = function (buffer) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(4));
                        for (var i = 0; i < 4; ++i) {
                            view.setUint8(i, buffer[i]);
                        }
                        return view.getFloat32(0, true);
                    } else {
                        return FloatUtils.ConvertArrayToNumber(buffer, false);
                    }
                };
                return Float;
            })();
            Decoding.Float = Float;

            var Double = (function () {
                function Double() {
                }
                Double.GetNumber = function (buffer) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(8));
                        for (var i = 0; i < 8; ++i) {
                            view.setUint8(i, buffer[i]);
                        }
                        return view.getFloat64(0, true);
                    } else {
                        return FloatUtils.ConvertArrayToNumber(buffer, true);
                    }
                };
                return Double;
            })();
            Decoding.Double = Double;

            var Zigzag = (function () {
                function Zigzag() {
                }
                Zigzag.DecodeZigzag16 = function (value) {
                    return (((0xffff & value) >>> 1) ^ (-(value & 1))) << 16 >> 16;
                };

                Zigzag.DecodeZigzag32 = function (value) {
                    return (value >>> 1) ^ (-(value & 1));
                };

                Zigzag.DecodeZigzag64 = function (value) {
                    // implement
                    // (value >>> 1) ^ (-(value & 1))
                    var tmpH = value.high & 1;
                    var high = value.high >>> 1;
                    var tmpL = value.low & 1;
                    var low = value.low >>> 1;
                    low = tmpH << 31 | low;
                    if (tmpL) {
                        low ^= 0xffffffff;
                        high ^= 0xffffffff;
                    }

                    var res = new Microsoft.Bond.UInt64("0");
                    res.low = low;
                    res.high = high;
                    return res;
                };
                return Zigzag;
            })();
            Decoding.Zigzag = Zigzag;
        })(Bond.Decoding || (Bond.Decoding = {}));
        var Decoding = Bond.Decoding;

        /** This class will be used to convert float/double to byte array on browsers which doesn't
        support html5.
        
        Format: IEEE-754, littleEndian, http://en.wikipedia.org/wiki/IEEE_754-1985
        
        \note
        1. Don't have negative zero. All zero will be positive zero.
        2. If the buffer array passed to ConvertArrayToFloat() is actual NaN or Inifinity value,
        exception will be raised.
        */
        var FloatUtils = (function () {
            function FloatUtils() {
            }
            FloatUtils.ConvertNumberToArray = function (num, isDouble) {
                if (!num) {
                    return isDouble ? this._doubleZero : this._floatZero;
                }

                var exponentBits = isDouble ? 11 : 8;
                var precisionBits = isDouble ? 52 : 23;

                // follow IEEE-754, exponent bias is 2^(k-1)-1 where k is the number of bits
                // in the exponent: http://en.wikipedia.org/wiki/Exponent_bias
                var bias = (1 << (exponentBits - 1)) - 1;
                var minExponent = 1 - bias;
                var maxExponent = bias;

                var sign = num < 0 ? 1 : 0;
                num = Math.abs(num);
                var intPart = Math.floor(num);
                var floatPart = num - intPart;

                var len = 2 * (bias + 2) + precisionBits;
                var buffer = new Array(len);
                var i = 0;
                while (i < len) {
                    buffer[i++] = 0;
                }

                // caculate the intPart
                i = bias + 2;
                while (i && intPart) {
                    buffer[--i] = intPart % 2;
                    intPart = Math.floor(intPart / 2);
                }

                // caculate the floatPart
                i = bias + 1;
                while (i < len - 1 && floatPart > 0) {
                    floatPart *= 2;
                    if (floatPart >= 1) {
                        buffer[++i] = 1;
                        --floatPart;
                    } else {
                        buffer[++i] = 0;
                    }
                }

                // find the first 1
                var firstBit = 0;
                for (; firstBit < len && !buffer[firstBit]; ++firstBit)
                    ;

                // caculate exponent
                var exponent = bias + 1 - firstBit;

                // caculate round
                var lastBit = firstBit + precisionBits;
                if (buffer[lastBit + 1]) {
                    for (i = lastBit; i > firstBit; --i) {
                        if (buffer[i] = 1 - buffer[i]) {
                            break;
                        }
                    }
                    if (i == firstBit) {
                        ++exponent;
                    }
                }

                // check overflow
                if (exponent > maxExponent || intPart) {
                    if (sign) {
                        return isDouble ? this._doubleNegInifinity : this._floatNegInifinity;
                    } else {
                        return isDouble ? this._doubleInifinity : this._floatInifinity;
                    }
                } else if (exponent < minExponent) {
                    return isDouble ? this._doubleZero : this._floatZero;
                }

                // caculate the result
                if (isDouble) {
                    var high = 0;
                    for (i = 0; i < 20; ++i) {
                        high = (high << 1) | buffer[++firstBit];
                    }

                    var low = 0;
                    for (; i < 52; ++i) {
                        low = (low << 1) | buffer[++firstBit];
                    }

                    high |= (exponent + bias) << 20;
                    high = (sign << 31) | (high & 0x7FFFFFFF);

                    var resArray = [
                        low & 0xff, (low >> 8) & 0xff, (low >> 16) & 0xff, low >>> 24,
                        high & 0xff, (high >> 8) & 0xff, (high >> 16) & 0xff, high >>> 24];
                    return resArray;
                } else {
                    var result = 0;
                    for (i = 0; i < 23; ++i) {
                        result = (result << 1) | buffer[++firstBit];
                    }

                    result |= (exponent + bias) << 23;
                    result = (sign << 31) | (result & 0x7FFFFFFF);

                    var resArray = [result & 0xff, (result >> 8) & 0xff, (result >> 16) & 0xff, result >>> 24];
                    return resArray;
                }
            };

            FloatUtils.ConvertArrayToNumber = function (buffer, isDouble) {
                var exponentBits = isDouble ? 11 : 8;
                var bias = (1 << (exponentBits - 1)) - 1;
                var sign = (buffer[isDouble ? 7 : 3] & 0x80) != 0;
                var exponent = isDouble ? ((buffer[7] & 0x7f) << 4) | ((buffer[6] & 0xf0) >> 4) : ((buffer[3] & 0x7f) << 1) | ((buffer[2] & 0x80) >> 7);

                // check the buffer is valid or not. If it is invalid (NaN, Infinitive), throw execption.
                if (exponent == 0xff) {
                    throw new Bond.Exception("Not a valid float/double buffer.");
                }

                var res = 1;
                var e = 1;
                if (isDouble) {
                    var high = ((buffer[6] & 0xf) << 28) | ((buffer[5] & 0xff) << 20) | ((buffer[4] & 0xff) << 12);
                    var low = (buffer[3] << 24) | ((buffer[2] & 0xff) << 16) | ((buffer[1] & 0xff) << 8) | (buffer[0] & 0xff);
                    if (!exponent && !high && !low) {
                        return 0.0;
                    }
                    for (var i = 0; i < 20; ++i) {
                        e /= 2;
                        if (high < 0) {
                            res += e;
                        }
                        high <<= 1;
                    }
                    for (var i = 0; i < 32; ++i) {
                        e /= 2;
                        if (low < 0) {
                            res += e;
                        }
                        low <<= 1;
                    }
                } else {
                    var data = ((buffer[2] & 0x7f) << 25) | ((buffer[1] & 0xff) << 17) | ((buffer[0] & 0xff) << 9);
                    if (!exponent && !data) {
                        return 0.0;
                    }
                    for (var i = 0; i < 23; ++i) {
                        e /= 2;
                        if (data < 0) {
                            res += e;
                        }
                        data <<= 1;
                    }
                }
                res *= Math.pow(2, exponent - bias);
                return sign ? 0 - res : res;
            };
            FloatUtils._floatZero = [0x00, 0x00, 0x00, 0x00];
            FloatUtils._doubleZero = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
            FloatUtils._floatInifinity = [0x00, 0x00, 0x80, 0x7F];
            FloatUtils._floatNegInifinity = [0x00, 0x00, 0x80, 0xFF];
            FloatUtils._doubleInifinity = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f];
            FloatUtils._doubleNegInifinity = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff];
            return FloatUtils;
        })();
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        (function (IO) {
            var MemoryStream = (function () {
                function MemoryStream() {
                    this._buffer = [];
                }
                /*override*/
                MemoryStream.prototype.WriteByte = function (byte) {
                    this._buffer.push(Bond.Number.ToByte(byte));
                };

                /*override*/
                MemoryStream.prototype.Write = function (buffer, offset, count) {
                    while (count--) {
                        this.WriteByte(buffer[offset++]);
                    }
                };

                /**
                * Returns the array of unsigned bytes from which this stream was created.
                */
                MemoryStream.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return MemoryStream;
            })();
            IO.MemoryStream = MemoryStream;
        })(Bond.IO || (Bond.IO = {}));
        var IO = Bond.IO;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        var FieldTag = (function () {
            function FieldTag(type, id) {
                this.Type = type;
                this.Id = id;
            }
            return FieldTag;
        })();
        Bond.FieldTag = FieldTag;

        var ContainerTag = (function () {
            function ContainerTag(elementType, size) {
                this.ElementType = elementType;
                this.Size = size;
            }
            return ContainerTag;
        })();
        Bond.ContainerTag = ContainerTag;

        var KeyValueContainerTag = (function () {
            function KeyValueContainerTag(keyType, valueType, size) {
                this.KeyType = keyType;
                this.ValueType = valueType;
                this.Size = size;
            }
            return KeyValueContainerTag;
        })();
        Bond.KeyValueContainerTag = KeyValueContainerTag;

        var Bonded = (function () {
            function Bonded() {
            }
            return Bonded;
        })();
        Bond.Bonded = Bonded;

        var Int64 = (function () {
            // BUG!!: need implement, currently, just handle 32bits number
            function Int64(numberStr) {
                this.low = 0;
                this.high = 0;
                this.low = parseInt(numberStr);
                if (this.low < 0) {
                    this.high = -1;
                }
            }
            Int64.prototype.Equals = function (numberStr) {
                var tmp = new Int64(numberStr);
                return this.low == tmp.low && this.high == tmp.high;
            };
            return Int64;
        })();
        Bond.Int64 = Int64;

        var UInt64 = (function () {
            // BUG!!: need implement, currently, just handle 32bits number
            function UInt64(numberStr) {
                this.low = 0;
                this.high = 0;
                this.low = parseInt(numberStr);
            }
            UInt64.prototype.Equals = function (numberStr) {
                var tmp = new UInt64(numberStr);
                return this.low == tmp.low && this.high == tmp.high;
            };
            return UInt64;
        })();
        Bond.UInt64 = UInt64;

        var Number = (function () {
            function Number() {
            }
            Number.ToByte = function (value) {
                return this.ToUInt8(value);
            };

            Number.ToInt8 = function (value) {
                var signMask = (value & 0x80) << 24 >> 24;
                return (value & 0x7f) | signMask;
            };

            Number.ToInt16 = function (value) {
                var signMask = (value & 0x8000) << 16 >> 16;
                return (value & 0x7fff) | signMask;
            };

            Number.ToInt32 = function (value) {
                var signMask = (value & 0x80000000);
                return (value & 0x7fffffff) | signMask;
            };

            Number.ToUInt8 = function (value) {
                return value & 0xff;
            };

            Number.ToUInt16 = function (value) {
                return value & 0xffff;
            };

            Number.ToUInt32 = function (value) {
                return value & 0xffffffff;
            };
            return Number;
        })();
        Bond.Number = Number;

        var Exception = (function () {
            function Exception(message) {
                this.Message = message;
            }
            return Exception;
        })();
        Bond.Exception = Exception;

        var KeyValuePair = (function () {
            function KeyValuePair() {
            }
            return KeyValuePair;
        })();
        Bond.KeyValuePair = KeyValuePair;
        ;

        var BrowserChecker = (function () {
            function BrowserChecker() {
            }
            BrowserChecker.IsDataViewSupport = function () {
                return typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
            };
            return BrowserChecker;
        })();
        Bond.BrowserChecker = BrowserChecker;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));

var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        

        var CompactBinaryProtocolWriter = (function () {
            function CompactBinaryProtocolWriter(stream) {
                this._stream = stream;
            }
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteBlob = function (blob) {
                this._stream.Write(blob, 0, blob.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteBool = function (value) {
                this._stream.WriteByte(value ? 1 : 0);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteContainerBegin = function (size, elementType) {
                this.WriteUInt8(elementType);
                this.WriteUInt32(size);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteMapContainerBegin = function (size, keyType, valueType) {
                this.WriteUInt8(keyType);
                this.WriteUInt8(valueType);
                this.WriteUInt32(size);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteContainerEnd = function () {
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteDouble = function (value) {
                var array = Bond.Encoding.Double.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFloat = function (value) {
                var array = Bond.Encoding.Float.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldBegin = function (type, id, metadata) {
                if (id <= 5) {
                    this._stream.WriteByte(type | (id << 5));
                } else if (id <= 0xff) {
                    this._stream.WriteByte(type | (6 << 5));
                    this._stream.WriteByte(id);
                } else {
                    this._stream.WriteByte(type | (7 << 5));
                    this._stream.WriteByte(id);
                    this._stream.WriteByte(id >> 8);
                }
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldEnd = function () {
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldOmitted = function (type, id, metadata) {
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt16 = function (value) {
                value = Bond.Encoding.Zigzag.EncodeZigzag16(value);
                this.WriteUInt16(value);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt32 = function (value) {
                value = Bond.Encoding.Zigzag.EncodeZigzag32(value);
                this.WriteUInt32(value);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt64 = function (value) {
                this.WriteUInt64(Bond.Encoding.Zigzag.EncodeZigzag64(value));
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt8 = function (value) {
                this._stream.WriteByte(Bond.Number.ToInt8(value));
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteString = function (value) {
                if (value == "") {
                    this.WriteUInt32(0);
                } else {
                    var array = Bond.Encoding.Utf8.GetBytes(value);
                    this.WriteUInt32(array.length);
                    this._stream.Write(array, 0, array.length);
                }
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteStructBegin = function (metadata, isBase) {
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteStructEnd = function (isBase) {
                this.WriteUInt8(isBase ? 1 /* BT_STOP_BASE */ : 0 /* BT_STOP */);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt16 = function (value) {
                var array = Bond.Encoding.Varint.GetBytes(Bond.Number.ToUInt16(value));
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt32 = function (value) {
                var array = Bond.Encoding.Varint.GetBytes(Bond.Number.ToUInt32(value));
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt64 = function (value) {
                var array = Bond.Encoding.Varint64.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt8 = function (value) {
                this._stream.WriteByte(Bond.Number.ToUInt8(value));
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteWString = function (value) {
                this.WriteUInt32(value.length);
                for (var i = 0; i < value.length; ++i) {
                    var charCode = value.charCodeAt(i);
                    this._stream.WriteByte(charCode);
                    this._stream.WriteByte(charCode >>> 8);
                }
            };
            return CompactBinaryProtocolWriter;
        })();
        Bond.CompactBinaryProtocolWriter = CompactBinaryProtocolWriter;

        var CompactBinaryProtocolReader = (function () {
            function CompactBinaryProtocolReader() {
            }
            return CompactBinaryProtocolReader;
        })();
        Bond.CompactBinaryProtocolReader = CompactBinaryProtocolReader;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var sct;
(function (sct) {
    var Utils = (function () {
        function Utils() {
        }
        Utils.IsSafari = function () {
            if (Utils._isSafari === null) {
                Utils._DetectBrowser();
            }
            return Utils._isSafari;
        };

        //
        // options: {
        //      type:   "GET" or "POST",
        //      url:
        //      headers: {
        //          key1: value1
        //          key2: value2
        //      },
        //      complete: function(xhr)
        // }
        //
        Utils.ajax = function (options) {
            var conn = Utils._createConnection();

            // for connection can't set the header, encode header to query parameters.
            if (!conn.setRequestHeader && options.headers) {
                var params = "read-from-query-string-instead-of-headers=true";
                for (var key in options.headers) {
                    params += "&";
                    params += encodeURIComponent(key);
                    params += "=";
                    params += encodeURIComponent(options.headers[key]);
                }

                if (options.url.indexOf("?") < 0) {
                    options.url += "?";
                } else {
                    options.url += "&";
                }
                options.url += params;
            }

            conn.open(options.type, options.url);
            if (conn.setRequestHeader && options.headers) {
                for (var key in options.headers) {
                    conn.setRequestHeader(key, options.headers[key]);
                }
            }

            if (options.complete) {
                conn.onload = function () {
                    if (typeof conn.status == "undefined") {
                        conn.status = 200;
                    }
                    options.complete(conn);
                };

                conn.ontimeout = function () {
                    if (typeof conn.status == "undefined") {
                        conn.status = 500;
                    }
                    options.complete(conn);
                };

                conn.onerror = function () {
                    options.complete(conn);
                };
            }

            conn.send(options.data);
        };

        // This is a workaround for IE8. That it does not support
        // Object.keys.
        Utils.keys = function (dict) {
            if (Object.keys) {
                return Object.keys(dict);
            } else {
                var keys = [];
                for (var eachKey in dict) {
                    if (dict.hasOwnProperty(eachKey)) {
                        keys.push(eachKey);
                    }
                }
                return keys;
            }
        };
        Utils.IsUsingXDomainRequest = function () {
            if (Utils._usingXDomainRequest == null) {
                var conn = new XMLHttpRequest();
                if (typeof conn.withCredentials == "undefined" && typeof XDomainRequest != "undefined") {
                    Utils._usingXDomainRequest = true;
                } else {
                    Utils._usingXDomainRequest = false;
                }
            }
            return Utils._usingXDomainRequest;
        };

        Utils._createConnection = function () {
            // for all browsers create standard XMLHttpRequest();
            var conn = new XMLHttpRequest();
            if (Utils.IsUsingXDomainRequest()) {
                // this is IE8/IE9, we should use XDomainRequest to support cross domain
                return new XDomainRequest();
            }
            return conn;
        };

        Utils._DetectBrowser = function () {
            var ua = navigator.userAgent.toLowerCase();
            if (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0) {
                Utils._isSafari = true;
            } else {
                Utils._isSafari = false;
            }
        };
        Utils._isSafari = null;
        Utils._usingXDomainRequest = null;
        return Utils;
    })();
    sct.Utils = Utils;
})(sct || (sct = {}));
var microsoft;
(function (microsoft) {
    (function (applications) {
        //------------------------------------------------------------------------------
        //     This code was generated by using the bondc tool and modified to remove
        //      deserialization because it is unused.
        //
        //     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
        //     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
        //     File     : DataPackage.ts
        //
        //     Changes to this file may cause incorrect behavior and will be lost when
        //     the code is regenerated.
        //------------------------------------------------------------------------------
        (function (telemetry) {
            (function (datamodels) {
                var utils = (function () {
                    function utils() {
                    }
                    utils.GetGuid = function () {
                        var rd = function () {
                            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1, 5);
                        };
                        return [rd(), rd(), '-', rd(), rd(), '-', rd(), '-', rd(), rd()].join("");
                    };

                    utils.GetTimeStamp = function () {
                        var val = new Date().getTime();
                        var timestamp = new Microsoft.Bond.Int64("0");
                        timestamp.low = val & 0xffffffff;
                        timestamp.high = Math.floor(val / 0x100000000);
                        return timestamp;
                    };

                    utils.GetTimeStampWithValue = function (timestamp) {
                        var bond_timestamp = new Microsoft.Bond.Int64("0");
                        bond_timestamp.low = timestamp & 0xffffffff;
                        bond_timestamp.high = Math.floor(timestamp / 0x100000000);
                        return bond_timestamp;
                    };
                    return utils;
                })();
                datamodels.utils = utils;

                (function (RecordType) {
                    RecordType[RecordType["NotSet"] = 0] = "NotSet";
                    RecordType[RecordType["Event"] = 1] = "Event";

                    // Deprecated, please use PerformanceCounterAzure and PerformanceCounterGfs instead
                    RecordType[RecordType["PerformanceCounter"] = 2] = "PerformanceCounter";
                    RecordType[RecordType["Anomaly"] = 3] = "Anomaly";
                    RecordType[RecordType["Prediction"] = 4] = "Prediction";
                    RecordType[RecordType["TraceLog"] = 5] = "TraceLog";
                    RecordType[RecordType["EventSourceLog"] = 6] = "EventSourceLog";
                    RecordType[RecordType["HttpLog"] = 7] = "HttpLog";
                    RecordType[RecordType["PerformanceCounterAzure"] = 8] = "PerformanceCounterAzure";
                    RecordType[RecordType["PerformanceCounterGfs"] = 9] = "PerformanceCounterGfs";
                })(datamodels.RecordType || (datamodels.RecordType = {}));
                var RecordType = datamodels.RecordType;

                (function (PIIScrubber) {
                    PIIScrubber[PIIScrubber["NotSet"] = 0] = "NotSet";
                    PIIScrubber[PIIScrubber["O365"] = 1] = "O365";
                    PIIScrubber[PIIScrubber["SkypeBI"] = 2] = "SkypeBI";
                    PIIScrubber[PIIScrubber["SkypeData"] = 3] = "SkypeData";
                })(datamodels.PIIScrubber || (datamodels.PIIScrubber = {}));
                var PIIScrubber = datamodels.PIIScrubber;

                (function (PIIKind) {
                    PIIKind[PIIKind["NotSet"] = 0] = "NotSet";
                    PIIKind[PIIKind["DistinguishedName"] = 1] = "DistinguishedName";
                    PIIKind[PIIKind["GenericData"] = 2] = "GenericData";
                    PIIKind[PIIKind["IPV4Address"] = 3] = "IPV4Address";
                    PIIKind[PIIKind["IPv6Address"] = 4] = "IPv6Address";
                    PIIKind[PIIKind["MailSubject"] = 5] = "MailSubject";
                    PIIKind[PIIKind["PhoneNumber"] = 6] = "PhoneNumber";
                    PIIKind[PIIKind["QueryString"] = 7] = "QueryString";
                    PIIKind[PIIKind["SipAddress"] = 8] = "SipAddress";
                    PIIKind[PIIKind["SmtpAddress"] = 9] = "SmtpAddress";
                    PIIKind[PIIKind["Identity"] = 10] = "Identity";
                    PIIKind[PIIKind["Uri"] = 11] = "Uri";
                    PIIKind[PIIKind["Fqdn"] = 12] = "Fqdn";

                    // Supports scrubbing of the last octet in a IPV4 address. E.g. 10.121.227.147 becomes 10.121.227.*
                    PIIKind[PIIKind["IPV4AddressLegacy"] = 13] = "IPV4AddressLegacy";
                })(datamodels.PIIKind || (datamodels.PIIKind = {}));
                var PIIKind = datamodels.PIIKind;

                var PII = (function () {
                    function PII() {
                        // 1: optional PIIScrubber ScrubType
                        this.ScrubType = 0 /* NotSet */;
                        // 2: optional PIIKind Kind
                        this.Kind = 0 /* NotSet */;
                        // 3: optional string RawContent
                        this.RawContent = "";
                    }
                    PII.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false);
                    };

                    PII.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null, isBase);

                        if (this.ScrubType != 0 /* NotSet */) {
                            writer.WriteFieldBegin(16 /* BT_INT32 */, 1, null);
                            writer.WriteInt32(this.ScrubType);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(16 /* BT_INT32 */, 1, null);
                        }
                        if (this.Kind != 0 /* NotSet */) {
                            writer.WriteFieldBegin(16 /* BT_INT32 */, 2, null);
                            writer.WriteInt32(this.Kind);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(16 /* BT_INT32 */, 2, null);
                        }
                        if (this.RawContent != "") {
                            writer.WriteFieldBegin(9 /* BT_STRING */, 3, null);
                            writer.WriteString(this.RawContent);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(9 /* BT_STRING */, 3, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };

                    PII.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false);
                    };

                    PII.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return PII;
                })();
                datamodels.PII = PII;

                var Record = (function () {
                    function Record() {
                        // 1: optional string Id
                        this.Id = utils.GetGuid();
                        // 3: optional int64 Timestamp
                        this.Timestamp = utils.GetTimeStamp();
                        // 5: optional string Type
                        this.Type = "";
                        // 6: optional string EventType
                        this.EventType = "";
                        // 13: optional map<string, string> Extension
                        this.Extension = new Microsoft.Bond.Collections.Map();
                        // 24: optional RecordType RecordType
                        this.RecordType = 0 /* NotSet */;
                        // 30: optional map<string, PII> PIIExtensions
                        this.PIIExtensions = new Microsoft.Bond.Collections.Map();
                    }
                    Record.prototype.AddOrReplacePII = function (key, piiValue, piiKind) {
                        var pii = new telemetry.datamodels.PII();
                        pii.RawContent = piiValue;
                        pii.Kind = piiKind;
                        pii.ScrubType = 1 /* O365 */;
                        this.PIIExtensions.AddOrReplace(key, pii);
                    };

                    Record.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false);
                    };

                    Record.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null, isBase);

                        if (this.Id != "") {
                            writer.WriteFieldBegin(9 /* BT_STRING */, 1, null);
                            writer.WriteString(this.Id);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(9 /* BT_STRING */, 1, null);
                        }
                        if (!this.Timestamp.Equals("0")) {
                            writer.WriteFieldBegin(17 /* BT_INT64 */, 3, null);
                            writer.WriteInt64(this.Timestamp);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(17 /* BT_INT64 */, 3, null);
                        }
                        if (this.Type != "") {
                            writer.WriteFieldBegin(9 /* BT_STRING */, 5, null);
                            writer.WriteString(this.Type);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(9 /* BT_STRING */, 5, null);
                        }
                        if (this.EventType != "") {
                            writer.WriteFieldBegin(9 /* BT_STRING */, 6, null);
                            writer.WriteString(this.EventType);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(9 /* BT_STRING */, 6, null);
                        }
                        if (this.Extension.Count()) {
                            writer.WriteFieldBegin(13 /* BT_MAP */, 13, null);
                            writer.WriteMapContainerBegin(this.Extension.Count(), 9 /* BT_STRING */, 9 /* BT_STRING */);
                            for (var i8 = 0; i8 < this.Extension.GetBuffer().length; ++i8) {
                                writer.WriteString(this.Extension.GetBuffer()[i8].Key);
                                writer.WriteString(this.Extension.GetBuffer()[i8].Value);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(13 /* BT_MAP */, 13, null);
                        }
                        if (this.RecordType != 0 /* NotSet */) {
                            writer.WriteFieldBegin(16 /* BT_INT32 */, 24, null);
                            writer.WriteInt32(this.RecordType);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(16 /* BT_INT32 */, 24, null);
                        }
                        if (this.PIIExtensions.Count()) {
                            writer.WriteFieldBegin(13 /* BT_MAP */, 30, null);
                            writer.WriteMapContainerBegin(this.PIIExtensions.Count(), 9 /* BT_STRING */, 10 /* BT_STRUCT */);
                            for (var i66 = 0; i66 < this.PIIExtensions.GetBuffer().length; ++i66) {
                                writer.WriteString(this.PIIExtensions.GetBuffer()[i66].Key);
                                this.PIIExtensions.GetBuffer()[i66].Value.WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(13 /* BT_MAP */, 30, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };

                    Record.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false);
                    };

                    Record.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return Record;
                })();
                datamodels.Record = Record;

                var DataPackage = (function () {
                    function DataPackage() {
                        // 2: optional string Source
                        this.Source = "";
                        // 5: optional string DataPackageId
                        this.DataPackageId = "";
                        // 6: optional int64 Timestamp
                        this.Timestamp = new Microsoft.Bond.Int64("0");
                        // 8: optional vector<clienttelemetry.data.v1.Record> Records
                        this.Records = [];
                    }
                    DataPackage.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false);
                    };

                    DataPackage.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null, isBase);

                        if (this.Source != "") {
                            writer.WriteFieldBegin(9 /* BT_STRING */, 2, null);
                            writer.WriteString(this.Source);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(9 /* BT_STRING */, 2, null);
                        }
                        if (this.DataPackageId != "") {
                            writer.WriteFieldBegin(9 /* BT_STRING */, 5, null);
                            writer.WriteString(this.DataPackageId);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(9 /* BT_STRING */, 5, null);
                        }
                        if (!this.Timestamp.Equals("0")) {
                            writer.WriteFieldBegin(17 /* BT_INT64 */, 6, null);
                            writer.WriteInt64(this.Timestamp);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(17 /* BT_INT64 */, 6, null);
                        }
                        if (this.Records.length) {
                            writer.WriteFieldBegin(11 /* BT_LIST */, 8, null);
                            writer.WriteContainerBegin(this.Records.length, 10 /* BT_STRUCT */);
                            for (var i52 = 0; i52 < this.Records.length; ++i52) {
                                this.Records[i52].WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(11 /* BT_LIST */, 8, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };

                    DataPackage.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false);
                    };

                    DataPackage.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return DataPackage;
                })();
                datamodels.DataPackage = DataPackage;

                var ClientToCollectorRequest = (function () {
                    function ClientToCollectorRequest() {
                        // 1: optional vector<clienttelemetry.data.v1.DataPackage> DataPackages
                        this.DataPackages = [];
                        // 2: optional int32 RequestRetryCount
                        this.RequestRetryCount = 0;
                    }
                    ClientToCollectorRequest.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false);
                    };

                    ClientToCollectorRequest.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null, isBase);

                        if (this.DataPackages.length) {
                            writer.WriteFieldBegin(11 /* BT_LIST */, 1, null);
                            writer.WriteContainerBegin(this.DataPackages.length, 10 /* BT_STRUCT */);
                            for (var i67 = 0; i67 < this.DataPackages.length; ++i67) {
                                this.DataPackages[i67].WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(11 /* BT_LIST */, 1, null);
                        }
                        if (this.RequestRetryCount != 0) {
                            writer.WriteFieldBegin(16 /* BT_INT32 */, 2, null);
                            writer.WriteInt32(this.RequestRetryCount);
                            writer.WriteFieldEnd();
                        } else {
                            writer.WriteFieldOmitted(16 /* BT_INT32 */, 2, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };

                    ClientToCollectorRequest.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false);
                    };

                    ClientToCollectorRequest.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return ClientToCollectorRequest;
                })();
                datamodels.ClientToCollectorRequest = ClientToCollectorRequest;
            })(telemetry.datamodels || (telemetry.datamodels = {}));
            var datamodels = telemetry.datamodels;
        })(applications.telemetry || (applications.telemetry = {}));
        var telemetry = applications.telemetry;
    })(microsoft.applications || (microsoft.applications = {}));
    var applications = microsoft.applications;
})(microsoft || (microsoft = {}));
/** \file clienttelemetry.ts
This filed defined the _sender class.
\author yuboxie
\date 2013-12
*/
var microsoft;
(function (microsoft) {
    (function (applications) {
        //TODO(abpanwar): rename files to better match the inner module
        (function (telemetry) {
            (function (_sender) {
                

                (function (CallbackEventType) {
                    CallbackEventType[CallbackEventType["SENT"] = 0] = "SENT";
                    CallbackEventType[CallbackEventType["SEND_FAILED"] = 1] = "SEND_FAILED";
                })(_sender.CallbackEventType || (_sender.CallbackEventType = {}));
                var CallbackEventType = _sender.CallbackEventType;

                (function (DATARV_ERROR) {
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_OK"] = 0] = "DATARV_ERROR_OK";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_EVENT"] = 1] = "DATARV_ERROR_INVALID_EVENT";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_CONFIG"] = 2] = "DATARV_ERROR_INVALID_CONFIG";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_DEPENDENCIES"] = 3] = "DATARV_ERROR_INVALID_DEPENDENCIES";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_STATUS"] = 4] = "DATARV_ERROR_INVALID_STATUS";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_ARG"] = 5] = "DATARV_ERROR_INVALID_ARG";
                })(_sender.DATARV_ERROR || (_sender.DATARV_ERROR = {}));
                var DATARV_ERROR = _sender.DATARV_ERROR;

                var Exception = (function () {
                    function Exception(errorCode) {
                        this._errorCode = 0 /* DATARV_ERROR_OK */;
                        this._errorCode = errorCode;
                    }
                    Exception.prototype.ErrorCode = function () {
                        return this._errorCode;
                    };

                    Exception.prototype.toString = function () {
                        switch (this._errorCode) {
                            case 0 /* DATARV_ERROR_OK */:
                                return "DATARV_ERROR_OK";
                            case 1 /* DATARV_ERROR_INVALID_EVENT */:
                                return "Event is invalid. Either event.Id is empty, or event.Timestamp is empty, or event.EventType is empty.";
                            case 2 /* DATARV_ERROR_INVALID_CONFIG */:
                                return "Invalid configuration. CollectorUrl is missing.";
                            case 3 /* DATARV_ERROR_INVALID_DEPENDENCIES */:
                                return "DATARV_ERROR_INVALID_DEPENDENCIES";
                            case 4 /* DATARV_ERROR_INVALID_STATUS */:
                                return "Telemetry Manager is not initialized.";
                            case 5 /* DATARV_ERROR_INVALID_ARG */:
                                return "TenantToken is null or empty, or events is null.";
                            default:
                                return "Unknown error";
                        }
                    };
                    return Exception;
                })();
                _sender.Exception = Exception;

                /** TelemetryConfig of TelemetryManager.
                
                \note
                TelemetryManager will hold the reference of this config. After you invoke
                Initialize(), you should never modify any content of this config object.
                Otherwise, the behavior is undefined.
                */
                var TelemetryConfig = (function () {
                    function TelemetryConfig() {
                    }
                    return TelemetryConfig;
                })();
                _sender.TelemetryConfig = TelemetryConfig;

                var TelemetryManagerFactory = (function () {
                    function TelemetryManagerFactory() {
                    }
                    TelemetryManagerFactory.CreateTelemetryManager = function () {
                        return new TelemetryManagerImpl();
                    };
                    return TelemetryManagerFactory;
                })();
                _sender.TelemetryManagerFactory = TelemetryManagerFactory;

                //
                // const
                //
                var Consts = (function () {
                    function Consts() {
                    }
                    Consts.MaxPackageSizeInBytes = function () {
                        return 3 * 1000 * 1000;
                    };
                    Consts.TimeIntervalForNextSendInMS = function () {
                        return 1 * 1000;
                    };
                    return Consts;
                })();
                ;

                //
                // Impl
                //
                /** TelemetryManager status.
                
                \note
                The status order is very important, don't modify it unless you know what you are doing.
                */
                var TelemetryManagerStatus;
                (function (TelemetryManagerStatus) {
                    TelemetryManagerStatus[TelemetryManagerStatus["Created"] = 0] = "Created";
                    TelemetryManagerStatus[TelemetryManagerStatus["Initialized"] = 1] = "Initialized";
                    TelemetryManagerStatus[TelemetryManagerStatus["Started"] = 2] = "Started";
                })(TelemetryManagerStatus || (TelemetryManagerStatus = {}));

                var TelemetryManagerImpl = (function () {
                    function TelemetryManagerImpl() {
                        this._MaxPackageSizeInBytes = Consts.MaxPackageSizeInBytes();
                        this._listeners = [];
                        this._status = 0 /* Created */;
                        this._ecsClient = null;
                        this._etag = null;
                        this._ecsCallback = null;
                        this._testServerResponseHook = null;
                    }
                    TelemetryManagerImpl.prototype.Initialize = function (config) {
                        if (this._status != 0 /* Created */) {
                            throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
                        }

                        if (!config || !config.collectorUrl) {
                            throw new Exception(2 /* DATARV_ERROR_INVALID_CONFIG */);
                        }

                        this._config = config;
                        this._Reset();
                        this._status = 1 /* Initialized */;

                        if (config.ecsClient) {
                            this._Verbose("ECS object assigned. Do integration");
                            this._ecsClient = config.ecsClient;
                        }

                        this._Verbose("Initialize() done");
                    };

                    TelemetryManagerImpl.prototype.AddListener = function (func) {
                        if (this._status < 1 /* Initialized */) {
                            throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
                        }

                        this._Verbose([
                            "AddListener(), status: ", this._status,
                            " old length: ", this._listeners.length,
                            " func: ", func
                        ].join(""));

                        for (var i = 0; i < this._listeners.length; ++i) {
                            if (this._listeners[i] == func) {
                                this._Verbose("the listener has been added already, index: " + i);
                                return;
                            }
                        }

                        this._listeners.push(func);

                        this._Verbose("AddListener() done, the new length: " + this._listeners.length);
                    };

                    TelemetryManagerImpl.prototype.RemoveListener = function (func) {
                        if (this._status < 1 /* Initialized */) {
                            throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
                        }

                        this._Verbose([
                            "RemoveListener(), status: ", this._status,
                            " old length: ", this._listeners.length,
                            " func: ", func
                        ].join(""));

                        for (var i = 0; i < this._listeners.length; ++i) {
                            if (this._listeners[i] == func) {
                                if (this._listeners.length == 1) {
                                    this._listeners = [];
                                } else if (i == this._listeners.length - 1) {
                                    this._listeners.pop();
                                } else {
                                    this._listeners[i] = this._listeners.pop();
                                }
                                this._Verbose([
                                    "this listener has been found, index: ", i,
                                    "new length: ", this._listeners.length
                                ].join(""));
                                return;
                            }
                        }

                        this._Verbose("listener isn't been found, new length" + this._listeners.length);
                    };

                    TelemetryManagerImpl.prototype.Start = function () {
                        // If it hasn't been initialized, throw exception.
                        if (this._status < 1 /* Initialized */) {
                            throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
                        }

                        this._Verbose([
                            "Start(), status:", this._status,
                            "tag:", TelemetryManagerImpl._tag
                        ].join(" "));

                        if (this._status >= 2 /* Started */) {
                            this._Verbose("Start() already, ignore");
                        }

                        if (this._ecsClient) {
                            this._ecsCallback = this._CreateEcsCallback();
                            this._ecsClient.AddListener(this._ecsCallback);
                            this._etag = this._ecsClient.GetETag();
                        }

                        // change the status to started.
                        ++TelemetryManagerImpl._tag;
                        this._status = 2 /* Started */;

                        this._Verbose([
                            "Start() done, status: ", this._status,
                            "tag: ", TelemetryManagerImpl._tag
                        ].join(""));
                    };

                    TelemetryManagerImpl.prototype.Stop = function () {
                        // If it hasn't been initialized, throw exception.
                        if (this._status < 1 /* Initialized */) {
                            throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
                        }

                        this._Verbose("Stop(), status: " + this._status);

                        if (this._status == 1 /* Initialized */) {
                            this._Verbose("Stop() already, ignore");
                            return;
                        }

                        //
                        // do stop work
                        //
                        // 1. cleanup states
                        this._Reset();

                        // 2. reset status to initailzied
                        this._status = 1 /* Initialized */;

                        this._Verbose("Stop() done, status: " + this._status);
                    };

                    TelemetryManagerImpl.prototype.Flush = function (func) {
                        if (!this._eventsCache.IsEmpty()) {
                            this._WorkThread(func);
                        }
                    };

                    TelemetryManagerImpl.prototype.SendAsync = function (tenantToken, events) {
                        if (this._status < 1 /* Initialized */) {
                            throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
                        }

                        this._Verbose([
                            "SendAsync(), status:", this._status,
                            "tenantToken:", tenantToken,
                            "count:", events.length
                        ].join(" "));

                        if (this._status < 2 /* Started */) {
                            this._Info("SendAsync(), not started, ignore, return false");
                            return false;
                        }

                        // check the input parameters
                        if (!tenantToken || !events) {
                            this._Error("SendAsync(), tenantToken or events is null or empty");
                            throw new Exception(5 /* DATARV_ERROR_INVALID_ARG */);
                        }

                        for (var i = 0; i < events.length; ++i) {
                            if (!events[i].Id || !TelemetryManagerImpl._eventTypeRegex.test(events[i].EventType) || events[i].Timestamp.Equals("0")) {
                                this._Error([
                                    "eventId:", events[i].Id,
                                    "eventType:", events[i].EventType,
                                    "timestamp high:", events[i].Timestamp.high,
                                    "timestamp low:", events[i].Timestamp.low
                                ].join(""));

                                throw new Exception(1 /* DATARV_ERROR_INVALID_EVENT */);
                            }
                        }

                        // put all events in events queue
                        this._eventsCache.AddEvents(tenantToken, events);

                        this._Verbose([
                            "SendAsync(), currentTimer: ", this._timer,
                            "eventsCacheIsEmpty", this._eventsCache.IsEmpty()
                        ].join(" "));

                        // if the events queue are not empty, and we haven't schedule the send
                        // action, schedule it at once.
                        // Don't invoke _WorkThread() directly, otherwise, it may block UI.
                        if (!this._eventsCache.IsEmpty() && !this._timer) {
                            this._ScheduleTimer(false);
                        }

                        this._Verbose("SendAsync() done");
                        return true;
                    };

                    TelemetryManagerImpl.prototype._WorkThread = function (flushCallback) {
                        var _this = this;
                        try  {
                            this._Verbose("_WorkThread, status: " + this._status);

                            if (this._status < 2 /* Started */) {
                                this._Verbose("_WorkThread, status is not started, return");
                                return;
                            }

                            // dequeue one tenants events
                            var item = this._eventsCache.DequeuEvents();
                            if (item == null) {
                                this._Verbose("_WorkThread, No events found, return");

                                // no more events need process, so clear the timer and return
                                this._CleanTimer();
                                return;
                            }

                            // pack the events and send
                            var result = this._PackEvents(item.tenantToken, item.events);

                            // add unsend events back to the queue
                            this._eventsCache.AddEvents(item.tenantToken, result.remainedEvents);

                            if (this._testServerResponseHook) {
                                //Using setTimeout with 100 ms to simulate the network time to and fro from the collector and calling _SendCallback asynchronously
                                var xhr = this._testServerResponseHook();
                                setTimeout(this._SendCallback(tag, item.tenantToken, result.sendEvents, xhr, null), 100);
                                return;
                            }

							// send it via request module
                            var tag = TelemetryManagerImpl._tag;
                            this._lastActiveTime = new Date().getTime();
							
							var resultArray = new Uint8Array(result.buffer);
							
							var options = {
                                method: 'POST',
                                url: this._config.collectorUrl,
                                headers: {
                                    'Content-Type': 'application/bond-compact-binary',
                                    "content-encoding": "base64",
                                    'Client-ID': 'NO_AUTH'
                                },
                                body: Microsoft.Bond.Encoding.Base64.GetString(result.buffer)
                            };
							
							if (item.tenantToken) {
                                options['headers']['x-apikey'] = item.tenantToken;
                            }
							
							(function(events, tenantToken) {
                                request(options, function(err, resp, body, flushCallback) {

									//Do the flush callback. Since this sending was scheduled 
									//synchronously don't schedule timer again for async sending.
									if (flushCallback != null) {
										flushCallback((resp ? resp.statusCode : 0), tenantToken, events);
									return;
									}
								
                                    var isSuccess = resp != null && resp.statusCode >= 200 && resp.statusCode < 300;
                                    for (var i = 0; i < _this._listeners.length; ++i) {
                                        _this._listeners[i](isSuccess ? 0 /* SENT */ : 1 /* SEND_FAILED */, (resp ? resp.statusCode : 0), tenantToken, events);
                                    }

                                    // schedule for next check if necessary
                                    if (!_this._eventsCache.IsEmpty()) {
                                        _this._Verbose("eventsCache is not empty, schedule for next run");
                                        _this._ScheduleTimer(false);
                                    } else {
                                        _this._Verbose("eventsCache is empty, stop schedule");
                                        _this._CleanTimer();
                                    }
                                });
                            })(result.sendEvents, item.tenantToken);

                            this._Verbose("_Workthread, send via jquery, tag: " + tag);
                        } catch (ex) {
                            this._Error("_WorkThread, exception: " + ex);
                        }
                    };

                    /** Package all events to a package.
                    
                    return value is json object:
                    {
                    buffer: bond serialize buffer (binary data),
                    sendEvents: the events are packaged.
                    },
                    
                    events contains unpackaged events.
                    */
                    TelemetryManagerImpl.prototype._PackEvents = function (tenantToken, events) {
                        this._Verbose("_PackageEvents, total Count: " + events.length);

                        // create the client to collector request
                        var collectorRequest = new telemetry.datamodels.ClientToCollectorRequest();

                        // create the data package
                        var pkg = new telemetry.datamodels.DataPackage();
                        pkg.Source = "JS_default_source";
                        pkg.DataPackageId = telemetry.datamodels.utils.GetGuid();
                        pkg.Timestamp = telemetry.datamodels.utils.GetTimeStamp();

                        // first, try to send all events
                        var buffer;
                        var sendEvents = events;
                        events = [];
                        while (true) {
                            pkg.Records = [];
                            pkg.Records.push.apply(pkg.Records, sendEvents);
                            collectorRequest.DataPackages = [];
                            collectorRequest.DataPackages.push(pkg);
                            buffer = this._Serialize(collectorRequest);
                            this._Verbose([
                                "_PackageEvents, sendEvents.length:", sendEvents.length,
                                "buffer.length:", buffer.length,
                                "MaxPackageSize:", this._MaxPackageSizeInBytes
                            ].join(""));

                            if (sendEvents.length == 1 || buffer.length < this._MaxPackageSizeInBytes) {
                                break;
                            }

                            // too large, we must reduce it.
                            var tmp = sendEvents.splice(0, Math.floor(sendEvents.length / 2));
                            this._Verbose("_PackageEvents, too large, package again");

                            // add the rest events back to events;
                            events.push.apply(events, sendEvents);
                            sendEvents = tmp;
                        }

                        this._Verbose([
                            "_PakcageEvents done, sendEventsCount:", sendEvents.length,
                            "buffer.length:", buffer.length,
                            "remained events:", events.length
                        ].join(""));

                        return { buffer: buffer, sendEvents: sendEvents, remainedEvents: events };
                    };

                    TelemetryManagerImpl.prototype._Serialize = function (collectorRequest) {
                        var stream = new Microsoft.Bond.IO.MemoryStream();
                        var writer = new Microsoft.Bond.CompactBinaryProtocolWriter(stream);
                        collectorRequest.Write(writer);
                        return stream.GetBuffer();
                    };

                    /** This function will handle the callback from ajax    */
                    TelemetryManagerImpl.prototype._SendCallback = function (tag, tenantToken, events, jqXHR, flushCallback) {
                        this._Verbose([
                            "_SendCallback",
                            "tag:", tag,
                            "current tag:", TelemetryManagerImpl._tag,
                            "tenantToken:", tenantToken,
                            "events count:", events.length,
                            "jqXHR:", jqXHR
                        ].join(""));

                        //Do the flush callback. Since this sending was scheduled synchronously don't schedule timer
                        //again for async sending.
                        if (flushCallback != null) {
                            flushCallback((jqXHR ? jqXHR.status : 0), tenantToken, events);
                            return;
                        }

                        var isSuccess = jqXHR != null && jqXHR.status >= 200 && jqXHR.status < 300;

                        // if the status is not sending (user may invoke Stop()), do nothing
                        if (this._status < 2 /* Started */ || tag < TelemetryManagerImpl._tag) {
                            this._Verbose("_SendCallback, is not started, or tag is not the same, return");
                            return;
                        }

                        // if need retry, put the events back to the events queue and
                        // try it later. 400 means the data format is not correct, so
                        // don't retry for this case.
                        //
                        // for IE 8/IE 9, there is no way to get the status code, don't retry also.
                        if (!isSuccess && (!jqXHR || jqXHR.status && jqXHR.status != 400)) {
                            this._Verbose("retry statusCode: " + (jqXHR ? jqXHR.status : 0));
                            this._eventsCache.AddEvents(tenantToken, events);
                            this._ScheduleTimer(true);
                            return;
                        }

                        for (var i = 0; i < this._listeners.length; ++i) {
                            this._listeners[i](isSuccess ? 0 /* SENT */ : 1 /* SEND_FAILED */, (jqXHR ? jqXHR.status : 0), tenantToken, events);
                        }

                        // schedule for next check if necessary
                        if (!this._eventsCache.IsEmpty()) {
                            this._Verbose("eventsCache is not empty, schedule for next run");
                            this._ScheduleTimer(false);
                        } else {
                            this._Verbose("eventsCache is empty, stop schedule");
                            this._CleanTimer();
                        }
                    };

                    TelemetryManagerImpl.prototype._CleanTimer = function () {
                        this._Verbose("_CleanTimer(), timer: " + this._timer);
                        if (this._timer) {
                            clearTimeout(this._timer);
                            this._timer = null;
                        }
                    };

                    /** Schedule Retry.
                    
                    This function will schedule re-try after X seconds. X value is determined
                    by the following algorithm:
                    1. for the 1st, X is a random value between 5~10 (5*2^0~5*2^1).
                    2. for the 2nd, X is a random value between 10~20 (5*2^1~5*2^2).
                    3. for the 3rd, X is a random value between 20~40 (5*2^2~5*2^3).
                    4. for the 4th, X is a random value between 40~80 (5*2^3~5*2^4).
                    5. for the 5th, X is a random value between 80~160 (5*2^4~5*2^5).
                    6. for the 6th, X is a random value between 160~320 (5*2^5~5*2^6).
                    7. Go back to 1.
                    */
                    TelemetryManagerImpl.prototype._ScheduleTimer = function (isRetry) {
                        var _this = this;
                        this._Verbose("_ScheduleTimer: isRetry: " + isRetry);

                        // clear previous timer always.
                        this._CleanTimer();

                        if (!isRetry) {
                            // next send will be in at least 1 second later
                            var X = 0;
                            var now = new Date().getTime();
                            var late = now - this._lastActiveTime;
                            if (late > Consts.TimeIntervalForNextSendInMS()) {
                                // we haven't scheduled in last 1 second, so schedule it at once.
                                X = 0;
                            } else {
                                X = Consts.TimeIntervalForNextSendInMS() - late;
                            }

                            this._timer = setTimeout(function () {
                                return _this._WorkThread(null);
                            }, X);
                            this._Verbose("_ScheduleTimer, next try: " + X);
                            this._rescheduleFactor = 1;
                        } else {
                            // retry
                            this._Verbose("_ScheduleTimer, current factor: " + this._rescheduleFactor);

                            var X = Math.floor(5 * this._rescheduleFactor * (1 + Math.random()));
                            this._timer = setTimeout(function () {
                                return _this._WorkThread(null);
                            }, X * 1000);
                            this._Verbose("_ScheduleTimer, next try (s): " + X);

                            this._rescheduleFactor <<= 1;
                            if (this._rescheduleFactor > 64) {
                                this._rescheduleFactor = 1;
                            }
                        }
                    };

                    //
                    // Log functions
                    //
                    TelemetryManagerImpl.prototype._Verbose = function (msg) {
                        if (this._config.log) {
                            this._config.log.Verbose("[TelemetryManagerImpl]: " + msg);
                        }
                    };

                    TelemetryManagerImpl.prototype._Info = function (msg) {
                        if (this._config.log) {
                            this._config.log.Info("[TelemetryManagerImpl]: " + msg);
                        }
                    };

                    TelemetryManagerImpl.prototype._Error = function (msg) {
                        if (this._config.log) {
                            this._config.log.Error("[TelemetryManagerImpl]: " + msg);
                        }
                    };

                    /** Clean all stats without listener queue */
                    TelemetryManagerImpl.prototype._Reset = function () {
                        this._Verbose("Reset()");

                        this._CleanTimer();

                        this._lastActiveTime = 0;
                        this._rescheduleFactor = 1;
                        this._sendingEvents = [];
                        this._eventsCache = new TelemetryEventCache();

                        // 3. Shutdown listener
                        if (this._ecsClient) {
                            this._ecsClient.RemoveListener(this._ecsCallback);
                            this._ecsCallback = null;
                            // Keep _ecs uncleared, following C++ version.
                        }
                    };

                    TelemetryManagerImpl.prototype._CreateEcsCallback = function () {
                        var _this = this;
                        return function (status) {
                            if (status == 0 /* CONFIG_UPDATED */) {
                                // Use number as status to avoid dependency.
                                _this._etag = _this._ecsClient.GetETag();
                            }
                        };
                    };

                    /******* TEST_INJECTION_START *******/
                    TelemetryManagerImpl.prototype.__GetListenerArray = function () {
                        return this._listeners;
                    };

                    TelemetryManagerImpl.prototype.__GetTotalEventsCount = function () {
                        return this._eventsCache.GetTotalEventsCount();
                    };

                    TelemetryManagerImpl.prototype.__IsScheduled = function () {
                        return this._timer != null;
                    };

                    TelemetryManagerImpl.prototype.__ChageMaxPackageSizeInKB = function (size) {
                        this._MaxPackageSizeInBytes = size * 1024;
                    };

                    TelemetryManagerImpl.prototype.__SetTestServerResponseHook = function (callback) {
                        this._testServerResponseHook = callback;
                    };
                    TelemetryManagerImpl._eventTypeRegex = /^[a-zA-Z0-9]([a-zA-Z0-9]|_){2,98}[a-zA-Z0-9]$/;
                    TelemetryManagerImpl._tag = 0;
                    return TelemetryManagerImpl;
                })();

                var TelemetryEventCache = (function () {
                    function TelemetryEventCache() {
                        this._events = {};
                        this._tokens = [];
                    }
                    TelemetryEventCache.prototype.AddEvents = function (tenantToken, events) {
                        if (!events.length) {
                            return;
                        }

                        if (!this._events[tenantToken]) {
                            this._events[tenantToken] = [];
                            this._tokens.push(tenantToken);
                        }
                        this._events[tenantToken].push.apply(this._events[tenantToken], events);
                    };

                    TelemetryEventCache.prototype.IsEmpty = function () {
                        return this._tokens.length == 0;
                    };

                    TelemetryEventCache.prototype.DequeuEvents = function () {
                        if (this._tokens.length == 0) {
                            return null;
                        }

                        var tenantToken = this._tokens.shift();
                        var events = this._events[tenantToken];
                        delete this._events[tenantToken];
                        return { tenantToken: tenantToken, events: events };
                    };

                    TelemetryEventCache.prototype.GetTotalEventsCount = function () {
                        var sum = 0;
                        for (var key in this._events) {
                            sum += this._events[key].length;
                        }
                        return sum;
                    };
                    return TelemetryEventCache;
                })();
            })(telemetry._sender || (telemetry._sender = {}));
            var _sender = telemetry._sender;
        })(applications.telemetry || (applications.telemetry = {}));
        var telemetry = applications.telemetry;
    })(microsoft.applications || (microsoft.applications = {}));
    var applications = microsoft.applications;
})(microsoft || (microsoft = {}));
var microsoft;
(function (microsoft) {
    (function (applications) {
        (function (telemetry) {
            var globalTelemetryManager = telemetry._sender.TelemetryManagerFactory.CreateTelemetryManager();

            /**
            * LogManager class allows initialization of the telemetry library.
            */
            var LogManager = (function () {
                function LogManager() {
                }
                LogManager.initialize = function (tenantToken) {
                    if (!LogManager._initialized) {
                        if (!tenantToken) {
                            throw new Exception(1 /* INVALID_TENANT_TOKEN */);
                        }
                        LogManager._defaultToken = tenantToken;
                        if (!LogManager._config.collectorUrl) {
                            LogManager._config.collectorUrl = "https://pipe.skype.com/Collector/3.0/";
                        }
                        globalTelemetryManager.Initialize(LogManager._config);
                        globalTelemetryManager.Start();
                        LogManager._initialized = true;
                    }
                };

                LogManager.initializeWithConfiguration = function (tenantToken, configuration) {
                    if (!configuration.collectorUrl) {
                        throw new Exception(4 /* INVALID_COLLECTOR_URL */);
                    }
                    LogManager._config.collectorUrl = configuration.collectorUrl;
                    LogManager.initialize(tenantToken);
                };

                LogManager.flush = function (func) {
                    globalTelemetryManager.Flush(func);
                };

                /**
                * When events have been sent or sent failed, you can get the notification
                * if you registered the listener. If the listener has been added already,
                * the function will do nothing.
                *
                * @param func (callbackType: microsoft.applications.telemetry._sender.CallbackEventType, responseCode: number, tenantToken: string,
                *  events: microsoft.applications.telemetry.datamodels.Record[]) => any
                */
                LogManager.addCallbackListener = function (func) {
                    if (LogManager._initialized) {
                        globalTelemetryManager.AddListener(func);
                    }
                };

                LogManager.isInitialized = function () {
                    return LogManager._initialized;
                };

                LogManager.getDefaultToken = function () {
                    return LogManager._defaultToken;
                };

                /******* TEST_INJECTION_START *******/
                LogManager.__setCollectorUrlToInt = function () {
                    LogManager._config.collectorUrl = "https://pipe.int.trafficmanager.net/Collector/3.0/";
                };

                LogManager.__backToUninitialized = function () {
                    LogManager._config = new telemetry._sender.TelemetryConfig();
                    globalTelemetryManager = telemetry._sender.TelemetryManagerFactory.CreateTelemetryManager();
                    LogManager._initialized = false;
                };
                LogManager._initialized = false;
                LogManager._defaultToken = null;
                LogManager._config = new telemetry._sender.TelemetryConfig();
                return LogManager;
            })();
            telemetry.LogManager = LogManager;
			exports.LogManager = LogManager;
            /**
            * Contains methods to log custom events.
            */
            var Logger = (function () {
                function Logger(tenantToken) {
                    this._initId = telemetry.datamodels.utils.GetGuid();
                    this._sequence = 0;
                    this._tenantToken = null;
                    this._contextProperties = new EventProperties();
                    if (!tenantToken) {
                        this._tenantToken = LogManager.getDefaultToken();
                    } else {
                        this._tenantToken = tenantToken;
                    }
                }
                /**
                * Log a custom event, including custom key-value properties.
                */
                Logger.prototype.logEvent = function (eventProperties) {
                    if (LogManager.isInitialized()) {
                        if (!eventProperties.name) {
                            throw new Exception(2 /* MISSING_EVENT_PROPERTIES_NAME */);
                        }
                        var event = this._createEventRecord(eventProperties.name, eventProperties.eventType);
                        this._addCustomPropertiesToEvent(event, eventProperties);
                        this._sendRecord(event);
                    }
                };

                Logger.prototype.setContext = function (key, value, pii) {
                    this._contextProperties.setProperty(key, value, pii);
                };

                Logger.prototype._createEventRecord = function (eventName, recordType) {
                    var event = new telemetry.datamodels.Record();
                    if (!recordType) {
                        recordType = "custom";
                    }
                    event.EventType = eventName.toLowerCase();
                    event.Type = recordType.toLowerCase();

                    event.Extension.Add("EventInfo.Source", "JS_default_source");
                    event.Extension.Add("EventInfo.InitId", this._initId);
                    this._sequence++;
                    event.Extension.Add("EventInfo.Sequence", this._sequence.toString());
                    event.Extension.Add("EventInfo.Name", eventName.toLowerCase());
                    var date = new Date();
                    event.Timestamp = telemetry.datamodels.utils.GetTimeStampWithValue(date.getTime());
                    event.Extension.Add("EventInfo.Time", date.toISOString());
                    event.Extension.Add("EventInfo.SdkVersion", "ACT-JS-" + clienttelemetry_build.version);

                    return event;
                };

                Logger.prototype._addCustomPropertiesToEvent = function (event, eventProperties) {
                    this._addEventPropertiesToEvent(event, this._contextProperties);
                    this._addEventPropertiesToEvent(event, eventProperties);
                };

                Logger.prototype._addEventPropertiesToEvent = function (event, eventProperties) {
                    if (eventProperties.timestamp && eventProperties.timestamp >= (new Date("1/1/2000")).getTime()) {
                        event.Timestamp = telemetry.datamodels.utils.GetTimeStampWithValue(eventProperties.timestamp);
                        event.Extension.AddOrReplace("EventInfo.Time", (new Date(eventProperties.timestamp)).toISOString());
                    }

                    var properties = eventProperties.properties;
                    if (properties && properties.length > 0) {
                        for (var i = 0; i < properties.length; i++) {
                            if (properties[i].key && (typeof properties[i].key == "string") && (properties[i].value || properties[i].value == false || properties[i].value == 0 || properties[i].value == "")) {
                                if (this._isPii(properties[i].pii)) {
                                    event.AddOrReplacePII(properties[i].key, properties[i].value.toString(), properties[i].pii);
                                    event.Extension.Remove(properties[i].key);
                                } else {
                                    event.Extension.AddOrReplace(properties[i].key, properties[i].value.toString());
                                    event.PIIExtensions.Remove(properties[i].key);
                                }
                            }
                        }
                    }
                };

                /**
                * Checks if the pii value is in the datamodels.PIIKind enum
                */
                Logger.prototype._isPii = function (pii) {
                    if (pii == (null || undefined || 0 /* NotSet */)) {
                        return false;
                    }
                    var result = false;
                    for (var val in telemetry.datamodels.PIIKind) {
                        if (!isNaN(val)) {
                            if (val == pii) {
                                result = true;
                            }
                        }
                    }
                    return result;
                };

                Logger.prototype._sendRecord = function (record) {
                    globalTelemetryManager.SendAsync(this._tenantToken, [record]);
                };
                return Logger;
            })();
            telemetry.Logger = Logger;
			exports.Logger = Logger;
            /**
            * Configuration for the ARIA logger.
            */
            var LogConfiguration = (function () {
                function LogConfiguration() {
                    /**
                    *  Set the collector url.
                    */
                    this.collectorUrl = null;
                }
                return LogConfiguration;
            })();
            telemetry.LogConfiguration = LogConfiguration;

            /**
            * eventProperties class allows adding custom key value pairs, including PII data to events.
            */
            var EventProperties = (function () {
                function EventProperties() {
                    /**
                    * Specify a name for this event. This is required if you send any custom key, value pairs.
                    */
                    this.name = null;
                    /**
                    * Override the timestamp on the event being sent, which is set to the current time by default.
                    */
                    this.timestamp = null;
                    /**
                    * Property bag that can be used to add custom extensions to the logged event.
                    */
                    this.properties = [];
                    /**
                    * Specify a type for this event. The type provided will be prefixed with the string
                    * "Custom.".
                    */
                    this.eventType = null;
                }
                /**
                * Add a named property and optionally tag it as PII.
                */
                EventProperties.prototype.setProperty = function (key, value, pii) {
                    if (!key || !EventProperties._propertyNameRegex.test(key)) {
                        throw new Exception(3 /* INVALID_PROPERTY_NAME */);
                    }
                    if (pii) {
                        this.properties.push({
                            key: key,
                            value: value,
                            pii: pii != 0 /* NotSet */ ? pii : null
                        });
                    } else {
                        this.properties.push({
                            key: key,
                            value: value,
                            pii: null
                        });
                    }
                };

                EventProperties._propertyNameRegex = /^[a-zA-Z0-9](([a-zA-Z0-9|_|.]){0,98}[a-zA-Z0-9])?$/;
                return EventProperties;
            })();
            telemetry.EventProperties = EventProperties;
			exports.EventProperties = EventProperties;

            var Property = (function () {
                function Property() {
                    this.key = null;
                    this.value = null;
                    this.pii = null;
                }
                return Property;
            })();
            telemetry.Property = Property;

            (function (TelemetryError) {
                TelemetryError[TelemetryError["INVALID_TENANT_TOKEN"] = 1] = "INVALID_TENANT_TOKEN";
                TelemetryError[TelemetryError["MISSING_EVENT_PROPERTIES_NAME"] = 2] = "MISSING_EVENT_PROPERTIES_NAME";
                TelemetryError[TelemetryError["INVALID_PROPERTY_NAME"] = 3] = "INVALID_PROPERTY_NAME";
                TelemetryError[TelemetryError["INVALID_COLLECTOR_URL"] = 4] = "INVALID_COLLECTOR_URL";
            })(telemetry.TelemetryError || (telemetry.TelemetryError = {}));
            var TelemetryError = telemetry.TelemetryError;

            /**
            * Helper class to throw exceptions.
            */
            var Exception = (function () {
                function Exception(errorCode) {
                    this.errorCode = null;
                    this.errorCode = errorCode;
                }
                Exception.prototype.ErrorCode = function () {
                    return this.errorCode;
                };

                Exception.prototype.toString = function () {
                    switch (this.errorCode) {
                        case 1 /* INVALID_TENANT_TOKEN */:
                            return "Invalid tenant token";
                        case 2 /* MISSING_EVENT_PROPERTIES_NAME */:
                            return "Eventproperties.name can not be null or empty";
                        case 3 /* INVALID_PROPERTY_NAME */:
                            return "Invalid Key. Key does not conform to regular expression ^[a-zA-Z0-9](([a-zA-Z0-9|_|.]){0,98}[a-zA-Z0-9])?$";
                        case 4 /* INVALID_COLLECTOR_URL */:
                            return "Collector url can't be null or empty.";
                        default:
                            return "Unknown error";
                    }
                };
                return Exception;
            })();
            telemetry.Exception = Exception;
        })(applications.telemetry || (applications.telemetry = {}));
        var telemetry = applications.telemetry;
    })(microsoft.applications || (microsoft.applications = {}));
    var applications = microsoft.applications;
})(microsoft || (microsoft = {}));
